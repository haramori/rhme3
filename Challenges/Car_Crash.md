# [Car Crash](https://rhme.riscure.com/3/challenge?id=9)

Reverse Engineering - 500pts

In addition to the challenge binary, an unencrypted binary is included for reverse engineering.

## Challenge text

This ECU firmware dump, or what's left of it, was taken out of a crashed prototype car. We have to extract the logs from it to investigate the crash. Bad luck, we get some strange garbage printed instead.

Attached is a program you can reverse-engineer and a program you can test. Don't mix them up.

## Solution

### Solution overview

The encryption algorithm has a broken inverse sbox.  The unencrypted binary can be run on an alternate XMEGA under hardware debugger control, and the incorrect values manually fixed during the initial breakpoint at startup.  Decrypting the log works after continuing.

### Static analysis

Disassemble the unencrypted binary as follows:

	$ avr-objcopy -I ihex -O elf32-avr ecu_dump.hex ecu_dump.elf
	$ avr-objdump -D ecu_dump.elf > ecu_dump.asm

Text section (by flash address|by PC address):

	Range 0x0000 to 0x1D85
	0x01FC|0x00FE: init()
	0x040E|0x0207: key_schedule()
	0x0E04|0x0702: cipher()
	0x1134|0x089A: menu()
	0x11E2|0x08F1: decrypt()
	0x134A|0x09A5: main()
	0x15B4|0x0ADA: putchar()
	0x1668|0x0B34: printf()
	0x16A8|0x0B54: getchar()
	0x16FE|0x0B7F: get_input()
	0x1C40|0x0E20: len()
	0x1D82|0x0EC1: halt()

Data section (by RAM address):

	Static range 0x2000 to 0x23F7
	Dynamic range 0x23F8 to 0x3FFF
	0x2000: pointer to 0x08A0 (USARTC0)
	0x2002: pointer to 0x0640 (PORTC)
	0x2004: 0x0804
	0x2006: USARTC0 handle
	0x2008: pointer to 0x09B0 (USARTD1)
	0x200A: pointer to 0x0660 (PORTD)
	0x200C: 0x8040
	0x200E: USARTD1 handle
	0x2010: sbox (256 byte)
	0x2110: inv_sbox (256 byte)
	0x2210: ??? (16 byte)
	0x2220: "1. Decrypt EDR data\n"
	0x2235: "2. Print EDR data\n"
	0x2248: "3. ECU status\n"
	0x2257: "Decrypting data\n"
	0x2268: key (256 bit)
	0x2288: "%s\n"
	0x228C: "Black box connected\n"
	0x22A1: "Option: %d\n"
	0x22AD: "Already decoded!\n"
	0x22BF: "Car not found\n"
	0x22CE: "Have you tried turning it on and off again?\n"
	0x22FB: "Wrong input\n"
	0x2308: encrypted log

The encryption algorithm is not familiar, but it has many of the same features as other familiar symetric algorithms like AES, to include: key schedule, block cipher, sbox and inverse sbox.  The sbox is very similar to the sbox for Kuznyechik (RFC 7801).  However, on careful examination, the inverse sbox contains multiple 0x00 values.  As sboxes should only contain one of each possible value, we need to examine this carefully to determine how broken it is.  Fortunately, the inverse sbox can be recreated from scratch using the sbox.

The following Python3 script calculates a new inverse sbox, compares it with the existing inverse sbox, and points out each flaw and how to fix it.

	sbox = [
		0xfc,0xee,0x99,0xc6,0x80,0x6e,0xa2,0x53,0xfb,0x18,0xfa,0xda,0x22,0x13,0x96,0xdf,
		0xe9,0xaa,0xf0,0xd0,0x4e,0x61,0xd6,0x6c,0x84,0xae,0xf1,0x29,0x5b,0x54,0x11,0xcb,
		0x60,0x81,0x65,0x86,0xe2,0x56,0x7c,0x21,0xc4,0x58,0x79,0x94,0x19,0xdd,0x17,0x93,
		0xd9,0x59,0x9a,0xa5,0xe3,0xbd,0x1c,0x76,0x0d,0x0a,0x3b,0xd7,0xe6,0x09,0x41,0x5a,
		0x36,0x34,0x2c,0xc2,0xea,0xc8,0xdb,0x33,0xb6,0x2a,0x68,0x7f,0xfd,0x7e,0xce,0xcc,
		0xb5,0x70,0x9c,0x8a,0x4d,0xd1,0xab,0xc5,0xbf,0x3c,0x12,0x03,0xd3,0xf9,0x8b,0x14,
		0x1f,0x77,0x0f,0x6d,0x1a,0x7b,0x91,0x83,0xb7,0x9b,0xe0,0x6f,0xd2,0x43,0xb2,0xf4,
		0xe4,0xa9,0x5d,0x73,0xb0,0x35,0x5c,0x30,0xbb,0x1b,0x82,0x57,0x8d,0x24,0x9e,0xcf,
		0x02,0x23,0x2e,0x3a,0x3e,0x31,0x95,0x1e,0x45,0xeb,0x44,0xf6,0x7d,0xf5,0xb9,0x46,
		0x3d,0x0e,0xec,0xde,0x7a,0x0c,0x67,0x6b,0xdc,0xe8,0xb1,0x51,0x01,0xa1,0x98,0x05,
		0xa7,0x4a,0x2f,0x37,0x15,0x92,0x62,0x00,0x55,0xb8,0xa0,0x88,0x64,0x42,0x26,0x4b,
		0xad,0x4f,0x08,0x0b,0x27,0x89,0x5e,0xf3,0xc9,0x74,0xaf,0xe5,0x69,0x4c,0x07,0xa3,
		0x9f,0x16,0xb3,0x04,0x87,0xac,0x85,0xf7,0x75,0x72,0x25,0xef,0x5f,0x9d,0xed,0x10,
		0x78,0xc7,0xcd,0x48,0xd4,0x3f,0xf8,0xfe,0x8c,0x8f,0x39,0xd5,0xca,0xd8,0x52,0x6a,
		0x20,0x71,0xff,0xe1,0x2d,0x2b,0x47,0x50,0x1d,0x90,0xf2,0x06,0xbe,0x38,0x66,0xc1,
		0xc0,0xa6,0xe7,0x40,0xa8,0x28,0xb4,0x8e,0x49,0xba,0xa4,0xc3,0x32,0x97,0x63,0xbc]

	inv_sbox = [
		0xa7,0x9c,0x80,0x5b,0xc3,0x9f,0xeb,0xbe,0xb2,0x3d,0x39,0xb3,0x95,0x38,0x91,0x62,
		0xcf,0x1e,0x00,0x0d,0x5f,0xa4,0xc1,0x2e,0x09,0x2c,0x64,0x79,0x36,0xe8,0x87,0x60,
		0xe0,0x27,0x0c,0x81,0x00,0xca,0xae,0xb4,0xf5,0x1b,0x49,0xe5,0x42,0xe4,0x82,0xa2,
		0x77,0x85,0xfc,0x47,0x41,0x75,0x40,0xa3,0xed,0xda,0x83,0x3a,0x59,0x90,0x84,0xd5,
		0xf3,0x3e,0xad,0x6d,0x8a,0x88,0x8f,0xe6,0xd3,0xf8,0xa1,0xaf,0xbd,0x54,0x14,0xb1,
		0xe7,0x9b,0xde,0x07,0x1d,0xa8,0x25,0x7b,0x29,0x31,0x3f,0x1c,0x00,0x72,0xb6,0x00,
		0x20,0x15,0xa6,0xfe,0xac,0x22,0xee,0x96,0x4a,0xbc,0xdf,0x97,0x17,0x63,0x05,0x6b,
		0x51,0xe1,0xc9,0x73,0xb9,0x00,0x37,0x61,0xd0,0x2a,0x94,0x65,0x26,0x00,0x4d,0x4b,
		0x04,0x21,0x7a,0x67,0x18,0xc6,0x23,0xc4,0xab,0xb5,0x53,0x5e,0xd8,0x7c,0x00,0xd9,
		0xe9,0x66,0xa5,0x2f,0x2b,0x86,0x0e,0xfd,0x9e,0x02,0x32,0x69,0x52,0xcd,0x7e,0xc0,
		0xaa,0x9d,0x06,0xbf,0xfa,0x33,0xf1,0xa0,0xf4,0x71,0x11,0x56,0xc5,0xb0,0x00,0xba,
		0x74,0x9a,0x6e,0xc2,0xf6,0x50,0x48,0x68,0xa9,0x8e,0xf9,0x78,0xff,0x35,0xec,0x00,
		0xf0,0xef,0x43,0xfb,0x28,0x57,0x03,0xd1,0x45,0xb8,0xdc,0x1f,0x4f,0xd2,0x4e,0x7f,
		0x13,0x55,0x6c,0x5c,0xd4,0xdb,0x16,0x3b,0xdd,0x30,0x0b,0x46,0x98,0x2d,0x93,0x0f,
		0x6a,0xe3,0x24,0x34,0x70,0xbb,0x3c,0xf2,0x99,0x10,0x44,0x89,0x92,0xce,0x01,0xcb,
		0x12,0x1a,0xea,0xb7,0x6f,0x8d,0x8b,0x00,0xd6,0x5d,0x0a,0x08,0x00,0x4c,0xd7,0xe2]

	correct_inv_sbox = [None] * 256
	for i in range(256):
		correct_inv_sbox[sbox[i]] = i

	inv_sbox_addr = 0x2110
	for i in range(256):
		if (inv_sbox[i] != correct_inv_sbox[i]):
			print(hex(inv_sbox_addr + i),":",hex(inv_sbox[i]),"should be",hex(correct_inv_sbox[i]))

Which produces the following output:

	0x2122 : 0x0 should be 0x5a
	0x2134 : 0x0 should be 0x7d
	0x216c : 0x0 should be 0x76
	0x216f : 0x0 should be 0xcc
	0x2185 : 0x0 should be 0xc8
	0x218d : 0x0 should be 0x8c
	0x219e : 0x0 should be 0xf7
	0x21be : 0x0 should be 0x19
	0x21cf : 0x0 should be 0x58
	0x2207 : 0x0 should be 0xc7

### Attack

Debug the unencrypted binary on an alternate XMEGA using the hardware debugging configuration described in the [Debugging AVR XMEGA raw binaries](../Preparation/debugging_raw_binaries.md) guide.

Follow these steps to decrypt the log and get the flag:
1. In Atmel Studio 7, select the menu item: Debug > Start Debugging and Break.  At the breakpoint, the binary has already initialized and copied the data section from flash into RAM.
2. In the Memory window, select "data INTERNAL_SRAM".
3. Manually edit each of the broken bytes in the inverse sbox according to the table of fix values above.
4. Select the menu item: Debug > Continue.
5. In a serial terminal, select 1 to decrypt, then select 2 to print.

Here is the terminal session:

	Black box connected
	1. Decrypt EDR data
	2. Print EDR data
	3. ECU status
	1
	Option: 1
	Decrypting data
	1. Decrypt EDR data
	2. Print EDR data
	3. ECU status
	2
	Option: 2
	2018-01-12 18:12:52.024 ECU     ERR     CAN DECODER ERROR, SKIPPING MSG
	2018-01-12 18:12:52.353 ECU     WRN     CAN BUFFER FULL
	2018-01-12 18:12:52.494 ABS     ERR     ABS OFFLINE
	2018-01-12 18:12:54.950 ECU     DBG     DUMP SERVICE FLAG 2127259039de83ac134df7e4f84d99fc
